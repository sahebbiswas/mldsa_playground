/**
 * PythonTab
 *
 * Generates runnable liboqs-python code that exactly reproduces what the user
 * did in the other tabs — using the actual hex key/sig/message values from the
 * current session. Three scripts are generated and kept live:
 *
 *   1. verify_signature.py  — uses inspect-tab inputs (pubkey + sig + message)
 *   2. sign_message.py      — uses gen-tab inputs (privkey + message → signature)
 *   3. generate_keys.py     — generates a fresh keypair; shows session keys for reference
 *
 * All three update automatically as the user works in the other tabs.
 */

import React, { useMemo, useState, useCallback, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import {
  Copy, CheckCircle2, XCircle,
  Search, Lock, Key,
  ChevronDown, ExternalLink,
} from 'lucide-react';
import { cn } from '../lib/utils';
import type { MLDSAVariant, SignMode, HashAlg } from '../services/mldsa';

// ─── Props ────────────────────────────────────────────────────────────────────

export interface PythonTabProps {
  variant: MLDSAVariant;

  // Inspect tab
  publicKey: string;
  signature: string;
  message: string;
  isMessageBinary: boolean;
  inspectMode: SignMode;
  inspectContext: string;
  inspectContextRawHex?: string;
  inspectHashAlg: HashAlg;

  // Generate / Sign tab
  genKeys: { publicKey: string; privateKey: string } | null;
  genMessage: string;
  isGenMessageBinary: boolean;
  genSignature: string;
  signMode: SignMode;
  signContext: string;
  signHashAlg: HashAlg;
  signDeterministic: boolean;
}

// ─── Code-generation helpers ──────────────────────────────────────────────────

const OQS_ALG: Record<MLDSAVariant, string> = {
  'ML-DSA-44': 'ML-DSA-44',
  'ML-DSA-65': 'ML-DSA-65',
  'ML-DSA-87': 'ML-DSA-87',
};

function cleanHex(h: string) { return h.replace(/\s/g, '').toLowerCase(); }

/** bytes.fromhex("…") assignment, wrapped at 88 chars */
function hexAssign(varName: string, hex: string, indent = '    '): string {
  const h = cleanHex(hex);
  const single = `${indent}${varName} = bytes.fromhex("${h}")`;
  if (single.length <= 88) return single;
  const chunks: string[] = [];
  for (let i = 0; i < h.length; i += 64) chunks.push(h.slice(i, i + 64));
  return (
    `${indent}${varName} = bytes.fromhex(\n` +
    chunks.map(c => `${indent}    "${c}"`).join('\n') +
    `\n${indent})`
  );
}

/** Escape a string for use inside a Python b"..." or "...".encode() literal.
 *  JSON.stringify handles all control characters (\n, \r, \t, \0, etc.);
 *  we then strip the surrounding JS double-quotes it adds. */
function escapePy(s: string): string {
  // JSON.stringify gives us a properly escaped JS string literal including
  // all control characters. Slice off the surrounding quotes.
  return JSON.stringify(s).slice(1, -1);
}

function msgAssign(msg: string, isBinary: boolean, indent = '    '): string {
  if (isBinary) return hexAssign('message', msg, indent);
  // Build a str and encode to UTF-8 rather than embedding a b"..." literal.
  // b"..." only allows ASCII + \xNN escapes; \uXXXX (from JSON.stringify) is not
  // valid Python bytes syntax, so non-ASCII text would produce a SyntaxError.
  return `${indent}message = "${escapePy(msg)}".encode('utf-8')`;
}

function ctxAssign(ctx: string, rawHex: string | undefined, indent = '    '): string {
  if (rawHex) return hexAssign('ctx', rawHex, indent) + '  # raw bytes from KAT vector';
  if (ctx)    return `${indent}ctx = "${escapePy(ctx)}".encode()`;
  return `${indent}ctx = b""`;
}

function modeLabel(mode: SignMode, alg: HashAlg) {
  return mode === 'pure' ? 'Pure ML-DSA' : `HashML-DSA / ${alg}`;
}

function preview(hex: string, n = 6): string {
  const h = cleanHex(hex);
  if (!h) return '(empty)';
  return h.length > n * 2 ? `${h.slice(0, n * 2)}…  (${h.length / 2} B)` : h;
}

function today() { return new Date().toISOString().slice(0, 10); }

// ─── Script generators ────────────────────────────────────────────────────────

function genVerify(p: PythonTabProps): string {
  const alg    = OQS_ALG[p.variant];
  const hasPk  = cleanHex(p.publicKey).length > 0;
  const hasSig = cleanHex(p.signature).length > 0;
  const hasMsg = p.message.length > 0;
  const warn   = (!hasPk || !hasSig || !hasMsg)
    ? '# ⚠  Some inputs are missing — fill in the placeholders before running.\n    '
    : '';

  return `#!/usr/bin/env python3
"""
ML-DSA Signature Verification
Generated by ML-DSA Inspector  ${today()}

  Variant : ${alg}
  Mode    : ${modeLabel(p.inspectMode, p.inspectHashAlg)}
  Context : ${p.inspectContextRawHex ? `raw 0x${preview(p.inspectContextRawHex, 3)}` : p.inspectContext ? `"${p.inspectContext}"` : 'none'}
  Pub key : ${hasPk  ? preview(p.publicKey)  : '(not loaded)'}
  Sig     : ${hasSig ? preview(p.signature)  : '(not loaded)'}
  Message : ${hasMsg ? (p.isMessageBinary ? preview(p.message) : `"${p.message.slice(0, 48)}${p.message.length > 48 ? '…' : ''}"`) : '(not loaded)'}

Requires: pip install liboqs-python
          https://github.com/open-quantum-safe/liboqs-python
"""

import oqs


def verify() -> bool:
    ${warn}alg = "${alg}"

    # ── Public key ────────────────────────────────────────────────────────────
${hasPk  ? hexAssign('public_key', p.publicKey) : '    public_key = bytes.fromhex("PASTE_PUBLIC_KEY_HEX_HERE")'}

    # ── Signature ─────────────────────────────────────────────────────────────
${hasSig ? hexAssign('signature',  p.signature) : '    signature  = bytes.fromhex("PASTE_SIGNATURE_HEX_HERE")'}

    # ── Message ───────────────────────────────────────────────────────────────
${hasMsg ? msgAssign(p.message, p.isMessageBinary) : '    message = b"PASTE_MESSAGE_HERE"'}

    # ── Context (must match the value used when signing) ──────────────────────
${ctxAssign(p.inspectContext, p.inspectContextRawHex)}
${p.inspectMode === 'hash-ml-dsa' ? `
    # HashML-DSA: liboqs handles prehashing internally — pass the original message.
` : ''}
    # ── Verify ────────────────────────────────────────────────────────────────
    with oqs.Signature(alg) as verifier:
        valid = verifier.verify(message, signature, public_key)

    status = "✓ VALID" if valid else "✗ INVALID"
    print(f"[{alg}]  {status}")
    if not valid:
        raise ValueError(
            "Verification failed — ensure message, public key, and context "
            "match exactly what was used during signing."
        )
    return valid


if __name__ == "__main__":
    verify()
`;
}

function genSign(p: PythonTabProps): string {
  const alg     = OQS_ALG[p.variant];
  const hasPriv = cleanHex(p.genKeys?.privateKey ?? '').length > 0;
  const hasPub  = cleanHex(p.genKeys?.publicKey  ?? '').length > 0;
  const hasSig  = cleanHex(p.genSignature).length > 0;
  const hasMsg  = p.genMessage.length > 0;
  const warn    = (!hasPriv || !hasPub || !hasMsg)
    ? '# ⚠  Some inputs are missing — fill in the placeholders before running.\n    '
    : '';

  const expectedNote = hasSig ? `
    # ── Expected signature from this Inspector session ────────────────────────
    # Deterministic mode was ${p.signDeterministic ? 'ON' : 'OFF'}.
    # ${p.signDeterministic
      ? 'With deterministic=True (dilithium-py), re-signing the same inputs gives identical bytes.'
      : 'ML-DSA signing is randomized by default — re-running produces a *different* valid signature.'}
${hexAssign('expected_sig', p.genSignature)}
    print(f"Session sig: {expected_sig.hex()[:32]}…  ({len(expected_sig)} B)")
` : '';

  const detNote = p.signDeterministic ? `
    # Deterministic signing note:
    # liboqs does not expose a derandomize flag. For byte-exact reproducibility use dilithium-py:
    #   from dilithium_py.ml_dsa import ML_DSA_${p.variant.slice(-2)}
    #   sig = ML_DSA_${p.variant.slice(-2)}.sign(secret_key, message, ctx=ctx, deterministic=True)
` : '';

  return `#!/usr/bin/env python3
"""
ML-DSA Key-Load & Sign
Generated by ML-DSA Inspector  ${today()}

  Variant      : ${alg}
  Mode         : ${modeLabel(p.signMode, p.signHashAlg)}
  Context      : ${p.signContext ? `"${p.signContext}"` : 'none'}
  Deterministic: ${p.signDeterministic ? 'yes (see note)' : 'no — randomized'}
  Secret key   : ${hasPriv ? preview(p.genKeys!.privateKey) : '(not loaded)'}
  Public key   : ${hasPub  ? preview(p.genKeys!.publicKey)  : '(not loaded)'}
  Message      : ${hasMsg  ? (p.isGenMessageBinary ? preview(p.genMessage) : `"${p.genMessage.slice(0, 48)}${p.genMessage.length > 48 ? '…' : ''}"`) : '(not loaded)'}

Requires: pip install liboqs-python
          https://github.com/open-quantum-safe/liboqs-python
"""

import oqs


def sign_and_verify() -> bytes:
    ${warn}alg = "${alg}"

    # ── Key pair from Inspector session ───────────────────────────────────────
    # To generate a fresh pair instead, see generate_keys.py
${hasPriv ? hexAssign('secret_key', p.genKeys!.privateKey) : '    secret_key = bytes.fromhex("PASTE_SECRET_KEY_HEX_HERE")'}

${hasPub  ? hexAssign('public_key', p.genKeys!.publicKey)  : '    public_key = bytes.fromhex("PASTE_PUBLIC_KEY_HEX_HERE")'}

    # ── Message ───────────────────────────────────────────────────────────────
${hasMsg ? msgAssign(p.genMessage, p.isGenMessageBinary) : '    message = b"PASTE_MESSAGE_HERE"'}

    # ── Context ───────────────────────────────────────────────────────────────
${ctxAssign(p.signContext, undefined)}
${p.signMode === 'hash-ml-dsa' ? '    # HashML-DSA: liboqs handles prehashing internally.\n' : ''}${detNote}${expectedNote}
    # ── Sign ──────────────────────────────────────────────────────────────────
    with oqs.Signature(alg, secret_key=secret_key) as signer:
        signature = signer.sign(message)

    print(f"Signature  ({len(signature)} B): {signature.hex()[:32]}…")

    # ── Round-trip verify ─────────────────────────────────────────────────────
    with oqs.Signature(alg) as verifier:
        valid = verifier.verify(message, signature, public_key)

    print(f"Round-trip: {'✓ VALID' if valid else '✗ INVALID'}")
    assert valid, "Round-trip verification failed — key pair mismatch?"
    return signature


if __name__ == "__main__":
    sign_and_verify()
`;
}

function genKeygen(p: PythonTabProps): string {
  const alg    = OQS_ALG[p.variant];
  const hasPub = cleanHex(p.genKeys?.publicKey  ?? '').length > 0;
  const hasSk  = cleanHex(p.genKeys?.privateKey ?? '').length > 0;
  const pkB    = hasPub ? cleanHex(p.genKeys!.publicKey).length  / 2 : '?';
  const skB    = hasSk  ? cleanHex(p.genKeys!.privateKey).length / 2 : '?';

  const sessionBlock = (hasPub && hasSk) ? `
    # ── Keys from your Inspector session (for reference / comparison) ─────────
${hexAssign('session_pk', p.genKeys!.publicKey)}
${hexAssign('session_sk', p.genKeys!.privateKey)}
    print(f"Session PK: {session_pk.hex()[:32]}…")
` : '    # (No keys loaded yet — generate some in the Key & Sign tab.)\n';

  return `#!/usr/bin/env python3
"""
ML-DSA Key Generation
Generated by ML-DSA Inspector  ${today()}

  Variant : ${alg}
  PK size : ${pkB} bytes
  SK size : ${skB} bytes

Requires: pip install liboqs-python
          https://github.com/open-quantum-safe/liboqs-python
"""

import json
import sys
import oqs


def generate(out_path: str = "mldsa_keys.json") -> tuple[bytes, bytes]:
    alg = "${alg}"

    print(f"Generating {alg} key pair…")
    with oqs.Signature(alg) as signer:
        public_key = signer.generate_keypair()
        secret_key = signer.export_secret_key()

    print(f"Public key  ({len(public_key)} B): {public_key.hex()[:32]}…")
    print(f"Secret key  ({len(secret_key)} B): {secret_key.hex()[:32]}…")
${sessionBlock}
    # ── Save (JSON compatible with Inspector's "Export JSON" button) ───────────
    with open(out_path, "w") as f:
        json.dump({
            "version":    1,
            "variant":    alg,
            "publicKey":  public_key.hex(),
            "privateKey": secret_key.hex(),
        }, f, indent=2)
    print(f"Saved → {out_path}")

    return public_key, secret_key


if __name__ == "__main__":
    generate(sys.argv[1] if len(sys.argv) > 1 else "mldsa_keys.json")
`;
}

// ─── Syntax highlighter ───────────────────────────────────────────────────────
//
// Hand-rolled — no external deps. Covers the Python subset that appears in the
// generated scripts: keywords, builtins, strings (b/f/triple/regular), comments,
// numbers (decimal + hex), decorators, operators.

type TT =
  | 'kw' | 'bi' | 'str' | 'fstr' | 'cmt'
  | 'num' | 'deco' | 'op' | 'plain';

interface Tok { t: TT; s: string }

const KW = new Set([
  'False','None','True','and','as','assert','async','await',
  'break','class','continue','def','del','elif','else','except',
  'finally','for','from','global','if','import','in','is',
  'lambda','nonlocal','not','or','pass','raise','return','try',
  'while','with','yield',
]);
const BI = new Set([
  'abs','all','any','bin','bool','bytes','callable','chr','dict',
  'dir','enumerate','eval','exec','filter','float','format',
  'frozenset','getattr','globals','hasattr','hash','hex','id',
  'input','int','isinstance','issubclass','iter','len','list',
  'locals','map','max','min','next','object','open','ord','pow',
  'print','range','repr','reversed','round','set','setattr','slice',
  'sorted','str','sum','super','tuple','type','vars','zip',
]);

const TOK_CLS: Record<TT, string> = {
  kw:    'text-violet-300 font-semibold',
  bi:    'text-sky-300',
  str:   'text-emerald-300',
  fstr:  'text-teal-200',
  cmt:   'text-[#E4E3E0]/25 italic',
  num:   'text-amber-300',
  deco:  'text-orange-300',
  op:    'text-[#E4E3E0]/40',
  plain: 'text-[#E4E3E0]/85',
};

/** Count consecutive backslashes ending at index pos (exclusive). */
function bsCount(src: string, pos: number): number {
  let n = 0;
  while (pos - 1 - n >= 0 && src[pos - 1 - n] === '\\') n++;
  return n;
}

function tokenize(src: string): Tok[] {
  const out: Tok[] = [];
  let i = 0;
  const ch = (d = 0) => src[i + d] ?? '';
  // `rest` removed — was unused

  while (i < src.length) {
    // Comment
    if (ch() === '#') {
      const end = src.indexOf('\n', i);
      const to  = end === -1 ? src.length : end;
      out.push({ t: 'cmt', s: src.slice(i, to) }); i = to; continue;
    }

    // Triple-quoted string  """ or '''
    if ((ch() === '"' || ch() === "'") && ch(1) === ch() && ch(2) === ch()) {
      const q   = src.slice(i, i + 3);
      const end = src.indexOf(q, i + 3);
      const to  = end === -1 ? src.length : end + 3;
      out.push({ t: 'str', s: src.slice(i, to) }); i = to; continue;
    }

    // f-string  f"…" or f'…'
    if ((ch() === 'f' || ch() === 'F') && (ch(1) === '"' || ch(1) === "'")) {
      const q = ch(1); let j = i + 2; let depth = 0;
      while (j < src.length) {
        if (src[j] === '{') { depth++; j++; continue; }
        if (src[j] === '}') { depth--; j++; continue; }
        if (depth === 0 && src[j] === q && bsCount(src, j) % 2 === 0) { j++; break; }
        j++;
      }
      out.push({ t: 'fstr', s: src.slice(i, j) }); i = j; continue;
    }

    // b-string  b"…" or b'…'
    if ((ch() === 'b' || ch() === 'B') && (ch(1) === '"' || ch(1) === "'")) {
      const q = ch(1); let j = i + 2;
      while (j < src.length && !(src[j] === q && bsCount(src, j) % 2 === 0)) j++;
      out.push({ t: 'str', s: src.slice(i, j + 1) }); i = j + 1; continue;
    }

    // Regular string  "…" or '…'
    if (ch() === '"' || ch() === "'") {
      const q = ch(); let j = i + 1;
      while (j < src.length && !(src[j] === q && bsCount(src, j) % 2 === 0)) j++;
      out.push({ t: 'str', s: src.slice(i, j + 1) }); i = j + 1; continue;
    }

    // Number — hex or decimal
    if (/[0-9]/.test(ch())) {
      let j = i;
      if (src.slice(i, i + 2).match(/0[xX]/)) {
        j += 2; while (j < src.length && /[0-9a-fA-F_]/.test(src[j])) j++;
      } else {
        while (j < src.length && /[0-9._eEjJ]/.test(src[j])) j++;
      }
      out.push({ t: 'num', s: src.slice(i, j) }); i = j; continue;
    }

    // Decorator  @…
    if (ch() === '@') {
      let j = i + 1;
      while (j < src.length && /[\w.]/.test(src[j])) j++;
      out.push({ t: 'deco', s: src.slice(i, j) }); i = j; continue;
    }

    // Word → keyword / builtin / plain
    if (/[a-zA-Z_]/.test(ch())) {
      let j = i;
      while (j < src.length && /\w/.test(src[j])) j++;
      const w = src.slice(i, j);
      out.push({ t: KW.has(w) ? 'kw' : BI.has(w) ? 'bi' : 'plain', s: w });
      i = j; continue;
    }

    // Operators
    if ('=+-*/%<>!&|^~'.includes(ch())) {
      let j = i;
      while (j < src.length && '=+-*/%<>!&|^~'.includes(src[j])) j++;
      out.push({ t: 'op', s: src.slice(i, j) }); i = j; continue;
    }

    out.push({ t: 'plain', s: ch() }); i++;
  }
  return out;
}

function HighlightedCode({ code }: { code: string }) {
  const toks = useMemo(() => tokenize(code), [code]);
  return (
    <code className="text-[11px] leading-[1.8] font-mono">
      {toks.map((t, i) => <span key={i} className={TOK_CLS[t.t]}>{t.s}</span>)}
    </code>
  );
}

// ─── Copy button ──────────────────────────────────────────────────────────────

function CopyBtn({ text, className }: { text: string; className?: string }) {
  const [st, setSt] = useState<'idle' | 'ok' | 'err'>('idle');
  const idleTimeoutRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);

  // Clear any pending idle-reset on unmount so setSt is never called after teardown.
  useEffect(() => () => clearTimeout(idleTimeoutRef.current), []);

  const go = useCallback(() => {
    clearTimeout(idleTimeoutRef.current);
    if (!navigator.clipboard) {
      setSt('err');
      idleTimeoutRef.current = setTimeout(() => setSt('idle'), 1600);
      return;
    }
    navigator.clipboard.writeText(text).then(
      () => { setSt('ok');  idleTimeoutRef.current = setTimeout(() => setSt('idle'), 1600); },
      () => { setSt('err'); idleTimeoutRef.current = setTimeout(() => setSt('idle'), 1600); },
    );
  }, [text]);
  return (
    <button onClick={go}
      className={cn(
        'flex items-center gap-1.5 px-3 py-1.5 border text-[10px] font-mono uppercase tracking-widest transition-all',
        st === 'ok'   && 'border-emerald-400/60 text-emerald-300 bg-emerald-900/20',
        st === 'err'  && 'border-red-400/60 text-red-300',
        st === 'idle' && 'border-[#E4E3E0]/15 text-[#E4E3E0]/50 hover:border-[#E4E3E0]/40 hover:text-[#E4E3E0]',
        className,
      )}
    >
      {st === 'ok'  ? <><CheckCircle2 size={11}/> Copied</>
       : st === 'err' ? <><XCircle size={11}/> Failed</>
       : <><Copy size={11}/> Copy</>}
    </button>
  );
}

// ─── Status badge ─────────────────────────────────────────────────────────────

function Badge({ ok, label }: { ok: boolean; label: string }) {
  return (
    <span className={cn(
      'inline-flex items-center gap-1.5 px-2 py-0.5 border text-[9px] font-mono tracking-wide',
      ok ? 'border-emerald-500/30 text-emerald-400/80' : 'border-[#141414]/15 text-[#141414]/30',
    )}>
      <span className={cn('w-1.5 h-1.5 rounded-full', ok ? 'bg-emerald-400' : 'bg-[#141414]/20')} />
      {label}
    </span>
  );
}

// ─── Script accordion section ─────────────────────────────────────────────────

type SectionId = 'verify' | 'sign' | 'keygen';

function ScriptSection({ id, icon, title, meta, code, open, onToggle }: {
  id: SectionId; icon: React.ReactNode; title: string; meta: string;
  code: string; open: boolean; onToggle: () => void;
}) {
  return (
    <div className="border border-[#141414]/12 overflow-hidden">
      <button type="button" onClick={onToggle}
        className="w-full flex items-center gap-3 px-5 py-3.5 bg-[#181818] hover:bg-[#1f1f1f] transition-colors text-left"
      >
        <span className="text-[#E4E3E0]/35 shrink-0">{icon}</span>
        <div className="flex-1 min-w-0">
          <span className="text-[11px] font-mono font-bold uppercase tracking-widest text-[#E4E3E0]/90">{title}</span>
          <span className="block text-[9px] font-mono text-[#E4E3E0]/35 mt-0.5 truncate">{meta}</span>
        </div>
        <ChevronDown size={13}
          className={cn('text-[#E4E3E0]/30 transition-transform duration-200 shrink-0', open && 'rotate-180')}
        />
      </button>

      <AnimatePresence initial={false}>
        {open && (
          <motion.div key="body"
            initial={{ height: 0 }} animate={{ height: 'auto' }} exit={{ height: 0 }}
            transition={{ duration: 0.18, ease: 'easeInOut' }}
            className="overflow-hidden"
          >
            <div className="relative group bg-[#0e0e0e]">
              <div className="absolute right-4 top-4 z-10 opacity-0 group-hover:opacity-100 transition-opacity">
                <CopyBtn text={code} />
              </div>
              <pre className="p-5 overflow-x-auto">
                <HighlightedCode code={code} />
              </pre>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

// ─── Main component ───────────────────────────────────────────────────────────

export default function PythonTab(props: PythonTabProps) {
  const { variant, publicKey, signature, message, genKeys, genSignature, genMessage } = props;

  const [open, setOpen] = useState<SectionId | ''>('verify');
  const toggle = (id: SectionId) => setOpen(p => p === id ? '' : id);

  const hasPk   = cleanHex(publicKey).length > 0;
  const hasSig  = cleanHex(signature).length > 0;
  const hasMsg  = message.length > 0;
  const hasKeys = !!(genKeys?.publicKey && genKeys?.privateKey);
  const hasGSig = cleanHex(genSignature).length > 0;
  const hasGMsg = genMessage.length > 0;

  const verifyCode = useMemo(() => genVerify(props), [
    variant, publicKey, signature, message, props.isMessageBinary,
    props.inspectMode, props.inspectContext, props.inspectContextRawHex, props.inspectHashAlg,
  ]);
  const signCode = useMemo(() => genSign(props), [
    variant, genKeys, genMessage, props.isGenMessageBinary, genSignature,
    props.signMode, props.signContext, props.signHashAlg, props.signDeterministic,
  ]);
  const keygenCode = useMemo(() => genKeygen(props), [variant, genKeys]);

  const activeCode =
    open === 'verify' ? verifyCode :
    open === 'sign'   ? signCode :
    open === 'keygen' ? keygenCode : '';

  return (
    <div className="space-y-6">

      {/* Title */}
      <div>
        <h2 className="font-serif italic text-2xl">Python Reference</h2>
        <p className="text-xs opacity-60 mt-1 leading-relaxed">
          Each script reflects your current session and runs directly with{' '}
          <code className="font-mono bg-[#141414]/10 px-1">liboqs-python</code>.
          Values update live as you work in the other tabs.
        </p>
      </div>

      {/* Session data status */}
      <div className="flex flex-wrap gap-2 items-center p-3.5 border border-[#141414]/15 bg-[#141414]/4">
        <span className="text-[9px] font-mono uppercase font-bold opacity-30 tracking-widest mr-1">Session</span>
        <Badge ok={hasPk}   label="Public key" />
        <Badge ok={hasSig}  label="Signature (inspect)" />
        <Badge ok={hasMsg}  label="Message (inspect)" />
        <Badge ok={hasKeys} label="Key pair" />
        <Badge ok={hasGMsg} label="Message (sign)" />
        <Badge ok={hasGSig} label="Signature (gen)" />
      </div>

      {/* Scripts */}
      <div className="space-y-px shadow-[0_4px_24px_rgba(0,0,0,0.15)] rounded-sm overflow-hidden">
        <ScriptSection id="verify" icon={<Search size={15}/>} title="verify_signature.py"
          meta={hasPk && hasSig && hasMsg
            ? `${variant}  ·  ${props.inspectMode === 'pure' ? 'Pure ML-DSA' : `HashML-DSA / ${props.inspectHashAlg}`}${props.inspectContext ? '  ·  ctx' : ''}  ·  sig ${(cleanHex(signature).length / 2).toLocaleString()} B`
            : 'Load a public key, signature, and message in the Inspect tab first'}
          code={verifyCode} open={open === 'verify'} onToggle={() => toggle('verify')}
        />
        <ScriptSection id="sign" icon={<Lock size={15}/>} title="sign_message.py"
          meta={hasKeys
            ? `${variant}  ·  ${props.signMode === 'pure' ? 'Pure ML-DSA' : `HashML-DSA / ${props.signHashAlg}`}${props.signContext ? '  ·  ctx' : ''}${props.signDeterministic ? '  ·  deterministic' : ''}`
            : 'Generate keys and sign a message in the Key & Sign tab first'}
          code={signCode} open={open === 'sign'} onToggle={() => toggle('sign')}
        />
        <ScriptSection id="keygen" icon={<Key size={15}/>} title="generate_keys.py"
          meta={hasKeys
            ? `${variant}  ·  PK ${(cleanHex(genKeys!.publicKey).length / 2).toLocaleString()} B  ·  SK ${(cleanHex(genKeys!.privateKey).length / 2).toLocaleString()} B`
            : `${variant}  ·  no keys generated yet`}
          code={keygenCode} open={open === 'keygen'} onToggle={() => toggle('keygen')}
        />
      </div>

      {/* Persistent copy button for the open script */}
      {open && (
        <div className="flex justify-end">
          <CopyBtn text={activeCode} />
        </div>
      )}

      {/* Footer */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 pt-2">
        <div className="p-4 border border-[#141414]/15 bg-[#141414]/4 space-y-2">
          <p className="text-[9px] font-mono uppercase font-bold opacity-50 tracking-widest">Install</p>
          <pre className="text-[10px] font-mono bg-[#141414] text-[#E4E3E0] p-2.5 leading-relaxed">pip install liboqs-python</pre>
          <a href="https://github.com/open-quantum-safe/liboqs-python" target="_blank" rel="noreferrer"
            className="flex items-center gap-1 text-[9px] font-mono opacity-40 hover:opacity-70 transition-opacity">
            <ExternalLink size={9}/> open-quantum-safe/liboqs-python
          </a>
        </div>
        <div className="p-4 border border-[#141414]/15 bg-[#141414]/4 space-y-2">
          <p className="text-[9px] font-mono uppercase font-bold opacity-50 tracking-widest">Alternatives</p>
          <ul className="space-y-1.5 text-[10px] font-mono opacity-50 leading-relaxed">
            <li><span className="opacity-80">dilithium-py</span> — pure Python, deterministic</li>
            <li><span className="opacity-80">cryptography ≥ 43</span> — FIPS 204 support</li>
            <li><span className="opacity-80">botan-python</span> — C++ binding, fast</li>
          </ul>
        </div>
        <div className="p-4 border border-[#141414]/15 bg-[#141414]/4 space-y-2">
          <p className="text-[9px] font-mono uppercase font-bold opacity-50 tracking-widest">Security Note</p>
          <p className="text-[10px] opacity-50 leading-relaxed">
            Private keys shown here come from your local in-browser session only.
            Never paste production private keys into a web tool outside a trusted environment.
          </p>
        </div>
      </div>
    </div>
  );
}
